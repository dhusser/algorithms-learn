
<div id="header" align="center">
  <a href="../">Назад к разделу</a>

  <a href="./">Вернуться на главную</a>
  
  Перейти к задачам платформы:
  <div id="platforms" align="center">
    <a href="./leetcode"><img src="https://img.shields.io/badge/Leetcode-FFA116?style=for-the-badge&logo=Leetcode&logoColor=white"
        alt="Leetcode Badge" /></a>
    <a href="./codewars"><img src="https://img.shields.io/badge/Codewars-B92F21?style=for-the-badge&logo=Codewars&logoColor=white"
        alt="Codewars Badge" /></a>
  </div>
</div>

### 1035. Uncrossed Lines

[Ссылка на задание](https://leetcode.com/problems/uncrossed-lines/)

По условию задачи у нас есть два целочисленных массива __nums1__ и __nums2__. Мы записываем числа из __nums1__ и __nums2__ (в порядке, в котором они заданы) на двух отдельных горизонтальных линиях.

Мы можем провести соединительные линии: прямую линию, соединяющую два числа __nums1[i]__ и __nums2[j]__, при условии, что:

__nums1[i] == nums2[j]__ и линия, которую мы проводим, не пересекается ни с одной другой соединительной линией (кроме горизонтальных).
Обратите внимание, что соединительная линия не может пересекать другие линии даже в конечных точках (то есть каждое число может принадлежать только одной соединительной линии).

Верните максимальное количество соединительных линий, которые мы можем провести таким образом.

#### Алгоритм решения

Существует несколько алгоритмов, которые можно использовать для решения данной задачи. Один из таких алгоритмов - это алгоритм динамического программирования, который называется алгоритм наибольшей общей подпоследовательности (Longest Common Subsequence).

Алгоритм наибольшей общей подпоследовательности (Longest Common Subsequence) является широко известным и используется в программировании. Впервые он был предложен рядом исследователей, включая Richard Bellman, Lester Ford Jr., и D. H. Lehmer, в различные периоды времени в 1950-х и 1960-х годах. Этот алгоритм был развит и исследован впоследствии множеством ученых и математиков.

Найдём длины массивов __nums1__ и __nums2__ и присвоим полученные значения переменным __n__ и __m__.

```typescript
const n = nums1.length,
      m = nums2.length;
```

Создадим двумерный массив __dp__ размером __(n + 1) x (m + 1)__ и заполним его нулями. Этот массив будет хранить максимальное количество соединительных линий для каждой комбинации чисел из __nums1__ и __nums2__.

```typescript
const dp: number[][] = Array.from({ length: n + 1}, () => Array(m + 1).fill(0))
```

Итерируем массивы __nums1__ и __nums2__ с помощью двух вложенных циклов.

```typescript
for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= m; j++) {
        if (nums1[i - 1] === nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
        else dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
    }
}
```

Если __nums1[i - 1] == nums2[j - 1]__, значит, можно провести соединительную линию между этими числами. При выполнении условия увеличеваем значение __dp[i][j]__ на единицу, которое соответствует количеству линий, включая текущую.
В противном случае, находим максимальное количество линий из предыдущих комбинаций: __dp[i][j - 1]__ и __dp[i - 1][j]__. Сохраним это значение в __dp[i][j]__.
После завершения всех итераций, значение в __dp[n][m]__ будет представлять максимальное количество соединительных линий, которые можно провести.
Вернём значение __dp[n][m]__ как результат.

#### Итоговое решение данной задачи:

```typescript
function maxUncrossedLinesDP(nums1: number[], nums2: number[]): number {
    const n = nums1.length,
          m = nums2.length;

    const dp: number[][] = Array.from({ length: n + 1}, () => Array(m + 1).fill(0))

    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= m; j++) {
            if (nums1[i - 1] === nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
            else dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
        }
    }

    return dp[n][m];
}
```

Функция __maxUncrossedLinesDP__ принимает два массива и возвращает максимальное количество соединительных линий, которые можно нарисовать.

__Примечание:__ В решении предполагается, что массивы __nums1__ и __nums2__ содержат только целые числа. Вы можете адаптировать код под свои потребности и изменить типы данных при необходимости.
